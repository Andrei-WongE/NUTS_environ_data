---
title: "Technical documentation NUTS1&2 level environmental data"
author: "Andrei Wong Espejo"
format: docx
editor: visual
---

<!-- using quarto install extension quarto-monash/report -->
<!-- using quarto install extension schochastics/academicons -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#Prevent scientific notation
options(scipen = 999)

# Load required packages ----
require(quartotemplate)


```

```{r Functions, include=FALSE}

# Tells you how many missing values in each column.
cc <- function(df) {
  print(df %>% is.na() %>% colSums())
}
# Tells you the percentage of missing value in each column.
cd <- function(df) {
  print(df %>% is.na() %>% colMeans())
}
# Calculate percentage
pct <- function(x) {
  (x / lag(x) - 1) * 100
}

```


# Introduction:

# Workflow:

Using the NUTS package we can:

-   nuts_classify() detects the NUTS version(s) and level(s) of a data set. Its output can be directly fed into the two other functions.

-   nuts_convert_version() converts your data to a desired NUTS version (2006, 2010, 2013, 2016, 2021). This transformation works in any direction.

-   nuts_aggregate() aggregates data to some upper-level NUTS code, i.e., it transforms NUTS-3 data to the NUTS-2 or NUTS-1 level (but not vice versa).

![](Figures/NUTS_workflow.png){.preview-image width="374" height="453"}

# Obtaining data

GHS (2023) 
Epochs: c(1975, 1980, 1985, 1990, 1995, 2000, 2005, 2010, 2015, 2020, 2025, 2030)
Resolution: 1km
Coordinate System: Mollweide

The combined information result into a new layer (resolution 1Km) which disergards administrative boundaries, and represents the presence and density of population.
In the GHS pop grid, the grid cell value represents the absolute number of inhabitants.

Advantages of population grids, from https://academy.europa.eu/pluginfile.php/17898/mod_scorm/intro/mod4-large.mp4?time=1656319630211 
Do not depend on the shape and size of census units
Do not depend on the boundary of census units
Grid cells have the same size and are stable over time
Grids integrate easily with other data
Grid cells can be assembled into custom zones

ERAS5 ()


NUTS1&2 (2016)


```{r}

```

# Data cleaning and wrangling

The spatial analysis operations to perform are:
- Aggregation: change of scale of the information, from 1km GHS population grid to 25km ERAS5 grid/cmip6-x0.25 grid. This means the reprojection of population grids maintaining volumes and minimising displacement of population.

- Zonal statistics:Summary of rasters by zones, at the NUTS1&2 regions.

_ Warping:  Changing the coordinate system of grids storing population counts is typically a challenging task, due to the need to keep the population totals unchanged (i.e. volume preservation). One critical aspect of population grids is that they represent a given spatial distribution and volume of people (i.e. total number of persons) for the area being represented. This volume (e.g. the population of a country in a given year) should not suffer significant changes when converting such a grid from the coordinate system in which it is produced to another coordinate system. From: ghs-popwarp_user_guide_online.pdf

Currently the number of population grid products with large territorial coverage is increasing, but each of the
products has different assumptions, technical specifications (Leyk et al. 2019) and therefore different fitness
for use. Population grids differ in population concepts, methods for production, spatial and temporal
resolution, temporal coverage, distribution policy and also spatial reference (coordinate system).

Operation: GHS 1km grid using Mollewiede projection to ERAS5 25km grid using WGS84 projection.


```{r}

```

# Data analysis and verification

```{r}
1 + 1
```

# Dataset building

##  era5-x0.25_A:
ERA5 data is provided at 0.25 x 0.25-degree resolution globally. This indicates it uses a regular latitude/longitude grid (WGS84/EPSG:4326).The 0.25-degree resolution means equal longitude spacing but decreasing latitude spacing towards poles

Panel with waves 2010-2022 for each NUTS1/NUTS2 region. 
Use population weights to aggregate the climate gridcell level data.
The population data comes from GHS data using as base the years of 2010,2015 and 2020. A linear arithmetic extrapolation is used to create years between the base years.

Population-weighted variable is produced by multiplying the value of the varaiable in a given cell with the population in the same cell, summing over the area, and the dividing by the total population in that area.

The API query function was parametrized with the following values:

| Variable | Code | Product | Scenarios | Aggregation | Model | Period | Type |
|----------|-------|----------|------------|-------------|--------|---------|------|
| Mean Temperature | tas | timeseries | historical_era5 | annual | Ensemble_all | 1950-2022 | timeseries |
| Cooling Degree Days (>18°C/65°F) | cdd65 | timeseries | historical_era5 | annual | Ensemble_all | 1950-2022 | timeseries |
| Heating Degree Days (<18°C/65°F) | hdd65 | timeseries | historical_era5 | annual | Ensemble_all | 1950-2022 | timeseries |
| Hot Days (Tmax>30°C) | hd30 | timeseries | historical_era5 | annual | Ensemble_all | 1950-2022 | timeseries |
| Very Hot Days (Tmax>35°C) | hd35 | timeseries | historical_era5 | annual | Ensemble_all | 1950-2022 | timeseries |
| Frost Days (Tmin<0°C) | fd | timeseries | historical_era5 | annual | Ensemble_all | 1950-2022 | timeseries |
| Ice Days (Tmax<0°C) | id | timeseries | historical_era5 | annual | Ensemble_all | 1950-2022 | timeseries |
| Days with Precipitation >20mm | r20mm | timeseries | historical_era5 | annual | Ensemble_all | 1950-2022 | timeseries |
| Days with Precipitation >50mm | r50mm | timeseries | historical_era5 | annual | Ensemble_all | 1950-2022 | timeseries |
| Precipitation | pr | timeseries | historical_era5 | annual | Ensemble_all | 1950-2022 | timeseries |

Code process:

1. ERA5 climate data gets cropped to NUTS regions. Both NUTS levels converted to rasters matching ERA5 grid.

2. Cell area weights calculated for each grid cell, accounting for latitude variation. Separate masks for NUTS1 and NUTS2.

3. Population raster resampled to ERA5 grid then weighted by cell areas. Higher resolution preserved until needed.

4. Population data masked to each NUTS level. Maintains spatial relationship with administrative boundaries.

5. ERA5 data weighted by cell area then masked to NUTS regions. Division by weights_nuts normalizes values.

6. Time subset applied to match population years (2010-2020). Final weighted means calculated using population-weighted values per NUTS region per year.

Each step preserves spatial relationships while accounting for cell area variations by latitude.

This implements weighted mean as:
Σ(value × lat_weight × pop_weight) / Σ(lat_weight × pop_weight)


```{r era5_data_a}
#| echo: false

# Load data
source("NUTS.R")

# Check data, just opens connection
(nc <- ncdf4::nc_open(here("Output", "climate_data_era5-x0.25_historical_era5_timeseries_1950-2022_combined.nc")))

# Open ERAS5 file
r <- terra::rast(here("Output", "climate_data_era5-x0.25_historical_era5_timeseries_1950-2022_combined.nc"))
crs(r) <- "EPSG:4326"

# Slicing time dimension to 2010-2022 eras5
subset_time <- terra::time(r) >= as.Date("2010-01-01")
r <- r[[subset_time]]

# Crop ERA5 extent to NUTS exent, NUTS1 has the same extent as NUTS2
era5_europe <- crop(r, ext(nuts1))

# Create raster versions of NUTS using ERA5 as template, to perform raster-based zonal statistics afterwards and proper area weighting, using 1st layer as template
nuts1_rast <- rasterize(nuts1, era5_europe[[1]], field = "NUTS_ID")
nuts2_rast <- rasterize(nuts2, era5_europe[[1]], field = "NUTS_ID")

# Latitudinal weighting, cellSize returns area of cells, accounting for latitude already
# https://stackoverflow.com/questions/68308376/why-do-terracellsize-and-rasterarea-produce-different-estimates-of-raste
weights <- terra::cellSize(era5_europe[[1]], unit = "km")

# Process population data to align extend and resolution of era5
pop_raster <- terra::rast(here("Output","pop_raster_2010_2020.tif"))

# Initialize lists
era5_data_a_nuts1_w <- list()
era5_data_a_nuts2_w <- list()

# Apply yearly NUTS level latitude and population weights for each cell of the layers of eras5 data
for(year in 2010:2020) {
  
  # Extract population for specific year
  pop_year <- pop_raster[[paste0("pop_", year)]]
  
  # Resample population to match ERA5 exactly
  pop_era5 <- terra::resample(pop_year, era5_europe[[1]], method = "sum")
  
  # Ensure extent matches exactly
  ext(pop_era5) <- ext(era5_europe[[1]])
  
  # Mask population to NUTS boundaries
  pop_nuts1 <- mask(pop_era5, nuts1_rast, updatevalue = 0)
  pop_nuts2 <- mask(pop_era5, nuts2_rast, updatevalue = 0)
  
  # Apply latitute weights to ERA5 data
  era5_weighted <- era5_europe * weights
  
  # Mask weighted ERA5 data to NUTS boundaries
  era5_data_nuts1 <- mask(era5_weighted, nuts1_rast)
  era5_data_nuts2 <- mask(era5_weighted, nuts2_rast)
  
  # Calculate weighted population means for each layer
  nuts1_means <- lapply(1:nlyr(era5_data_nuts1), function(i) {
    
    weighted.mean(era5_data_nuts1[[i]], pop_nuts1, na.rm = TRUE)
  })
  
  nuts2_means <- lapply(1:nlyr(era5_data_nuts2), function(i) {
    
    weighted.mean(era5_data_nuts2[[i]], pop_nuts2, na.rm = TRUE)
  })
  
  # Store results
  era5_data_a_nuts1_w[[as.character(year)]] <- do.call(c, nuts1_means)
  era5_data_a_nuts2_w[[as.character(year)]] <- do.call(c, nuts2_means)
}

# Export results as SpatRaster objects
terra::writeRaster(rast(era5_data_a_nuts1_w), 
                  here("Output", "era5_data_a_nuts1_w.tif"), 
                  overwrite = TRUE)

terra::writeRaster(rast(era5_data_a_nuts2_w), 
                  here("Output", "era5_data_a_nuts2_w.tif"), 
                  overwrite = TRUE)

```

```{r verify_era5_data_a}

# Verify results
# Verify alignment, masking reviews extent
compareGeom(rast(era5_data_a_nuts1_w), rast(era5_data_a_nuts2_w))

# Verify temporal dimension
print(paste("Time steps in original:", nlyr(era5_europe)))
print(paste("Time steps in NUTS1:", nlyr(rast(era5_data_a_nuts1_w))))
print(paste("Time steps in NUTS2:", nlyr(rast(era5_data_a_nuts2_w))))

print("Weight statistics by latitude:")
# Sample weights at different latitudes to show variation
y_coords <- seq(min(as.vector(ext(era5_europe)[3:4])), 
                max(as.vector(ext(era5_europe)[3:4])), 
                length.out=5)
for(y in y_coords) {
  p <- vect(cbind(0, y), crs=crs(weights))
  w <- extract(weights, p)
  print(paste("Latitude:", round(y, 2), "Weight:", round(w[1,2], 2)))
}

# Verify coverage
print("\nVerifying NUTS coverage:")
print(paste("Number of NUTS1 regions with data:", 
           global(rast(era5_data_a_nuts1_w), fun="notNA")[1,1]))
print(paste("Number of NUTS2 regions with data:", 
           global(rast(era5_data_a_nuts2_w), fun="notNA")[1,1]))
```


```{r summary_era5_data_a}
# Summary stats across time periods
# Mean for each NUTS1 region across all time steps
means_nuts1 <- global(era5_data_a_nuts1, mean, na.rm = TRUE)

# Basic temporal stats
temporal_stats <- data.frame(
  min = global(era5_data_a_nuts1, min, na.rm = TRUE),
  max = global(era5_data_a_nuts1, max, na.rm = TRUE),
  mean = global(era5_data_a_nuts1, mean, na.rm = TRUE),
  sd = global(era5_data_a_nuts1, sd, na.rm = TRUE)
)

# Time series plot 
values <- terra::as.data.frame(era5_data_a_nuts1, xy = TRUE)
time_series <- ggplot(values, aes(x=seq_len(ncol(values)-2), y = value)) +
  geom_line() +
  theme_minimal() +
  labs(title="ERA5 Time Series by NUTS1 Region",
       x="Time Steps", 
       y="Value")

# Boxplot of values by region
box_plot <- ggplot(values, aes(y=value)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title="Distribution of ERA5 Values",
       y="Value")

print(temporal_stats)
print(time_series)
print(box_plot)
```


##  era5-x0.25_B:
Dataset with one value per variable for each NUTS1/NUTS2 region. 
We will add anomalues to this value to create future climate scenarios


The API query function was parametrized with the following values:

Caveat:pr available timeperiod is 1991-2020.

| Variable | Code | Product | Scenarios | Aggregation | Model | Period | Type |
|----------|-------|----------|------------|-------------|--------|---------|------|
| Mean Temperature | tas | Climatology | historical_era5 | annual | Ensemble_all | 1995-2014 | climatology |
| Cooling Degree Days (>18°C/65°F) | cdd65 | Climatology | historical_era5 | annual | Ensemble_all | 1995-2014 | climatology |
| Heating Degree Days (<18°C/65°F) | hdd65 | Climatology | historical_era5 | annual | Ensemble_all | 1995-2014 | climatology |
| Hot Days (Tmax>30°C) | hd30 | Climatology | historical_era5 | annual | Ensemble_all | 1995-2014 | climatology |
| Very Hot Days (Tmax>35°C) | hd35 | Climatology | historical_era5 | annual | Ensemble_all | 1995-2014 | climatology |
| Frost Days (Tmin<0°C) | fd | Climatology | historical_era5 | annual | Ensemble_all | 1995-2014 | climatology |
| Ice Days (Tmax<0°C) | id | Climatology | historical_era5 | annual | Ensemble_all | 1995-2014 | climatology |
| Days with Precipitation >20mm | r20mm | Climatology | historical_era5 | annual | Ensemble_all | 1995-2014 | climatology |
| Days with Precipitation >50mm | r50mm | Climatology | historical_era5 | annual | Ensemble_all | 1995-2014 | climatology |
| Precipitation | pr | Climatology | historical_era5 | annual | Ensemble_all | 1995-2014 | climatology |

```{r era5-x0.25_b}
s <- terra::rast(here("Output", "climate_data_era5-x0.25_historical_era5_climatology_1991-2020_combined.nc"
))
crs(s) <- "epsg:4326"

"climatology-popcount-annual-mean_pop-x0.25_gpw-v4-rev11-historical_climatology_mean_1995-2014.nc"
  
# Slicing time dimension to 1991-2020 eras5
start_date <- as.Date("1991-01-01")
end_date <- as.Date("2020-12-31")
subset_time <- terra::time(s) >= start_date & terra::time(s) <= end_date
s <- s[[subset_time]]

# Aggregate to create era5_data_b
r <- terra::rast(here("Output", "climate_data_era5-x0.25_historical_era5_timeseries_1995-2014_combined.nc"))
crs(r) <- "epsg:4326"

r <- terra::rast((r, s)

# Slice time of era5_data_c to 1995-2014 to match era5_data_b
start_date <- as.Date("1995-01-01")
end_date <- as.Date("2014-12-31")
subset_time <- terra::time(r) >= start_date & terra::time(r) <= end_date
r <- r[[subset_time]]

# Crop ERA5 extent to NUTS exent, NUTS1 has the same extent as NUTS2
era5_europe <- crop(r, ext(nuts1))

# Create raster versions of NUTS using ERA5 as template, to perform raster-based zonal statistics afterwards and proper area weighting, using 1st layer as template
nuts1_rast <- rasterize(nuts1, era5_europe[[1]], field = "NUTS_ID")
nuts2_rast <- rasterize(nuts2, era5_europe[[1]], field = "NUTS_ID")

# Latitudinal weighting, cellSize returns area of cells, accounting for latitude already
# https://stackoverflow.com/questions/68308376/why-do-terracellsize-and-rasterarea-produce-different-estimates-of-raste
weights <- terra::cellSize(era5_europe[[1]], unit = "km")

# Process population data to align extend and resolution of era5
pop_raster <- terra::rast(here("Output","pop_raster_2010_2020.tif"))

# Initialize lists
era5_data_a_nuts1_w <- list()
era5_data_a_nuts2_w <- list()

# Apply yearly NUTS level latitude and population weights for each cell of the layers of eras5 data
for(year in 2010:2020) {
  
  # Extract population for specific year
  pop_year <- pop_raster[[paste0("pop_", year)]]
  
  # Resample population to match ERA5 exactly
  pop_era5 <- terra::resample(pop_year, era5_europe[[1]], method = "sum")
  
  # Ensure extent matches exactly
  ext(pop_era5) <- ext(era5_europe[[1]])
  
  # Mask population to NUTS boundaries
  pop_nuts1 <- mask(pop_era5, nuts1_rast, updatevalue = 0)
  pop_nuts2 <- mask(pop_era5, nuts2_rast, updatevalue = 0)
  
  # Apply latitute weights to ERA5 data
  era5_weighted <- era5_europe * weights
  
  # Mask weighted ERA5 data to NUTS boundaries
  era5_data_nuts1 <- mask(era5_weighted, nuts1_rast)
  era5_data_nuts2 <- mask(era5_weighted, nuts2_rast)
  
  # Calculate weighted population means for each layer
  nuts1_means <- lapply(1:nlyr(era5_data_nuts1), function(i) {
    
    weighted.mean(era5_data_nuts1[[i]], pop_nuts1, na.rm = TRUE)
  })
  
  nuts2_means <- lapply(1:nlyr(era5_data_nuts2), function(i) {
    
    weighted.mean(era5_data_nuts2[[i]], pop_nuts2, na.rm = TRUE)
  })
  
  # Store results
  era5_data_a_nuts1_w[[as.character(year)]] <- do.call(c, nuts1_means)
  era5_data_a_nuts2_w[[as.character(year)]] <- do.call(c, nuts2_means)
}



# Export results as SpatRaster objects
terra::writeRaster(rast(era5_data_a_nuts1_w), 
                  here("Output", "era5_data_a_nuts1_w.tif"), 
                  overwrite = TRUE)

terra::writeRaster(rast(era5_data_a_nuts2_w), 
                  here("Output", "era5_data_a_nuts2_w.tif"), 
                  overwrite = TRUE)
```


##  cmip6-x0.25_A:


We get the anolamy, which is then added to the current data (ERAS5) and then aggreated at NUTS2 and NUTS1 using future population projections

CCKP presents projection as absolute values and/or as anomalies (from the historical reference period: 1995-2014 for CMIP6)
Download the anomaly directly , just one point in time (climatology 2040-2059)



| Variable | Description | Product | Scenarios | Model | Period | Type |
|----------|------------|---------|-----------|--------|---------|-------|
| tas | Mean temperature | anomaly | ssp245 & ssp585 | Ensemble_all | 2040-2059 | climatology |
| cdd65 | Cooling degree days (temp > 18°C) | anomaly | ssp245 & ssp585 | Ensemble_all | 2040-2059 | climatology |
| hdd65 | Heating degree days (temp < 18°C) | anomaly | ssp245 & ssp585 | Ensemble_all | 2040-2059 | climatology |
| hd30 | Number of hot days (Tmax > 30°C) | anomaly | ssp245 & ssp585 | Ensemble_all | 2040-2059 | climatology |
| hd35 | Number of very hot days (Tmax > 35°C) | anomaly | ssp245 & ssp585 | Ensemble_all | 2040-2059 | climatology |
| fd | Number of frost days (Tmin < 0°C) | anomaly | ssp245 & ssp585 | Ensemble_all | 2040-2059 | climatology |
| id | Number of ice days (Tmax < 0°C) | anomaly | ssp245 & ssp585 | Ensemble_all | 2040-2059 | climatology |
| r20mm | Days with precipitation > 20mm | anomaly | ssp245 & ssp585 | Ensemble_all | 2040-2059 | climatology |
| r50mm | Days with precipitation > 50mm | anomaly | ssp245 & ssp585 | Ensemble_all | 2040-2059 | climatology |
| pr | Precipitation | anomaly | ssp245 & ssp585 | Ensemble_all | 2040-2059 | climatology |


```{r}

```

## cmip6-x0.25_B:

Las varaiables de precipitación usamos el cambio relativo, tenemos que calcularlo, nos falta los datos de base period simulation
Relative change= anomaly climatology / simulation base climatology



Future climate= climatology historic (1995-2014) + (CMIP climatology anomaly)

Future population= GHS 2020 + (popcount 2040-2059 - popcount 1995-2014). Es la anomalía calculada en el punto 2.

Con esas proyecciones, se puede agregar.

 

Para las variables de precipitación (pr, r20mm, r50mm) hay que aplicar el growth rate 

Future climate= climatology historic (1995-2014)* (1+ CMIP climatology anomaly/CMIP historic)

Because climate simulations do not reproduce observed high-frequency weather extremes, and may exhibit biases relative to current climate, we do not directly compare simulated future exposures against their observed counterparts, but instead employ the 'delta' change method of computing differences in exposure between simulated current and future climates. Namely:

![](Figures/download.png){.preview-image width="674" height="453"}
![](Figures/download1.png){.preview-image width="674" height="453"}




![](Figures/download2.png){.preview-image width="674" height="153"}
 

Vamos a tener que hacer eso para el clima y la población (a nivel grid) para luego obtener population weighted climate projections a nivel NUTS. En nuestro caso:

 

Future climate=Current climate (ERAS) + anomaly (CMIP)

Future population= Current population (GHS)+ anomaly (WB NASA population data)

| Collection | Variables | Product | Scenarios | Aggregation | Model | Time Period | Percentile | Product Type | Statistic |
|-----------|-----------|---------|-----------|-------------|-------|-------------|------------|--------------|------------|
| cmip6-x0.25_B | r20mm | Climatology | ssp245 & ssp585 | Annual | Ensemble_all | 1995-2014 | Median | Climatology | Mean number of days with precipitation > 20mm |
| cmip6-x0.25_B | r50mm | Climatology | ssp245 & ssp585 | Annual | Ensemble_all | 1995-2014 | Median | Climatology | Mean number of days with precipitation > 50mm |
| cmip6-x0.25_B | pr | Climatology | ssp245 & ssp585 | Annual | Ensemble_all | 1995-2014 | Median | Climatology | Mean Precipitation |


```{r}
# Wraggling per variable
```

